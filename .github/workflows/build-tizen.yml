name: Build Kodi for Tizen

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:  # Allows manual trigger from Actions tab

jobs:
  build-tizen:
    name: Build Tizen TPK
    runs-on: ubuntu-22.04  # Use 22.04 for better availability and performance
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for version info
      
      - name: Free up disk space
        run: |
          # Remove unnecessary packages to free up space
          sudo rm -rf /usr/share/dotnet
          sudo rm -rf /opt/ghc
          sudo rm -rf "/usr/local/share/boost"
          sudo rm -rf "$AGENT_TOOLSDIRECTORY"
          df -h
      
      - name: Install build dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            build-essential \
            cmake \
            curl \
            libcurl4-openssl-dev \
            git \
            python3 \
            python3-pip \
            python3-dev \
            libpython3-dev \
            autoconf \
            automake \
            libtool \
            pkg-config \
            gawk \
            gperf \
            zip \
            unzip \
            wget \
            default-jre \
            nasm \
            yasm \
            libssl-dev
          
          # Verify CMake and curl are available
          cmake --version
          which cmake
          pkg-config --modversion libcurl
      
      - name: Cache Tizen SDK
        id: cache-tizen-sdk
        uses: actions/cache@v4
        with:
          path: ~/tizen-studio
          key: tizen-sdk-6.1-${{ runner.os }}
      
      - name: Download and install Tizen SDK
        if: steps.cache-tizen-sdk.outputs.cache-hit != 'true'
        run: |
          cd /tmp
          # Try Tizen Studio 6.1 first, fallback to 5.0 if not available
          wget http://download.tizen.org/sdk/Installer/tizen-studio_6.1/web-cli_Tizen_Studio_6.1_ubuntu-64.bin || \
          wget http://download.tizen.org/sdk/Installer/tizen-studio_5.0/web-cli_Tizen_Studio_5.0_ubuntu-64.bin
          
          # Install whichever version was downloaded
          chmod +x web-cli_Tizen_Studio_*.bin
          ./web-cli_Tizen_Studio_*.bin --accept-license $HOME/tizen-studio
      
      - name: Install Tizen packages and setup alternative toolchain
        run: |
          # Try to install Tizen toolchain (likely to fail)
          $HOME/tizen-studio/package-manager/package-manager-cli.bin install \
            NativeToolchain-Gcc-9.2 \
            PLATFORM-6.0-NativeAppDevelopment-CLI || true
          
          # Check if Tizen toolchain installed
          if [ -d "$HOME/tizen-studio/tools/arm-linux-gnueabi-gcc-9.2/bin" ] && \
             [ -f "$HOME/tizen-studio/tools/arm-linux-gnueabi-gcc-9.2/bin/arm-linux-gnueabi-gcc" ]; then
            echo "âœ“ Tizen toolchain installed successfully"
          else
            echo "âš  Tizen toolchain not available, using alternative ARM GCC"
            
            # Install ARM cross-compiler from Ubuntu repos
            # Use SOFT-FLOAT version (gnueabi) not hard-float (gnueabihf)
            # Tizen uses -mfloat-abi=softfp which requires soft-float libs
            sudo apt-get install -y \
              gcc-arm-linux-gnueabi \
              g++-arm-linux-gnueabi \
              binutils-arm-linux-gnueabi \
              libc6-dev-armel-cross
            
            # Create symlink structure to match Tizen paths
            mkdir -p $HOME/tizen-studio/tools/arm-linux-gnueabi-gcc-9.2/bin
            cd $HOME/tizen-studio/tools/arm-linux-gnueabi-gcc-9.2/bin
            
            # Create symlinks using SOFT-FLOAT compiler (gnueabi, not gnueabihf)
            # Standard arm-linux-gnueabi-* names
            ln -sf /usr/bin/arm-linux-gnueabi-gcc arm-linux-gnueabi-gcc
            ln -sf /usr/bin/arm-linux-gnueabi-g++ arm-linux-gnueabi-g++
            ln -sf /usr/bin/arm-linux-gnueabi-ar arm-linux-gnueabi-ar
            ln -sf /usr/bin/arm-linux-gnueabi-ranlib arm-linux-gnueabi-ranlib
            ln -sf /usr/bin/arm-linux-gnueabi-ld arm-linux-gnueabi-ld
            ln -sf /usr/bin/arm-linux-gnueabi-as arm-linux-gnueabi-as
            ln -sf /usr/bin/arm-linux-gnueabi-nm arm-linux-gnueabi-nm
            ln -sf /usr/bin/arm-linux-gnueabi-objdump arm-linux-gnueabi-objdump
            ln -sf /usr/bin/arm-linux-gnueabi-strip arm-linux-gnueabi-strip
            ln -sf /usr/bin/arm-linux-gnueabi-readelf arm-linux-gnueabi-readelf
            
            # ALSO create arm-tizen-linux-gnueabi-* names (for host triplet matching)
            ln -sf /usr/bin/arm-linux-gnueabi-gcc arm-tizen-linux-gnueabi-gcc
            ln -sf /usr/bin/arm-linux-gnueabi-g++ arm-tizen-linux-gnueabi-g++
            ln -sf /usr/bin/arm-linux-gnueabi-ar arm-tizen-linux-gnueabi-ar
            ln -sf /usr/bin/arm-linux-gnueabi-ranlib arm-tizen-linux-gnueabi-ranlib
            ln -sf /usr/bin/arm-linux-gnueabi-ld arm-tizen-linux-gnueabi-ld
            ln -sf /usr/bin/arm-linux-gnueabi-as arm-tizen-linux-gnueabi-as
            ln -sf /usr/bin/arm-linux-gnueabi-nm arm-tizen-linux-gnueabi-nm
            ln -sf /usr/bin/arm-linux-gnueabi-objdump arm-tizen-linux-gnueabi-objdump
            ln -sf /usr/bin/arm-linux-gnueabi-strip arm-tizen-linux-gnueabi-strip
            ln -sf /usr/bin/arm-linux-gnueabi-readelf arm-tizen-linux-gnueabi-readelf
            
            echo "âœ“ Alternative ARM toolchain configured (soft-float)"
          fi
          
          # Verify toolchain is now available
          echo "Toolchain binaries:"
          ls -la $HOME/tizen-studio/tools/arm-linux-gnueabi-gcc-9.2/bin/
          echo ""
          echo "GCC version (arm-linux-gnueabi):"
          $HOME/tizen-studio/tools/arm-linux-gnueabi-gcc-9.2/bin/arm-linux-gnueabi-gcc --version
          echo ""
          echo "GCC version (arm-tizen-linux-gnueabi):"
          $HOME/tizen-studio/tools/arm-linux-gnueabi-gcc-9.2/bin/arm-tizen-linux-gnueabi-gcc --version
      
      - name: Cache Kodi dependencies
        id: cache-kodi-deps
        uses: actions/cache@v4
        with:
          path: ~/kodi-tizen-deps
          key: kodi-deps-${{ hashFiles('tools/depends/**') }}
          restore-keys: |
            kodi-deps-
      
      - name: Patch for C++17 compatibility
        run: |
          # Patch configure.ac to use C++17 instead of C++20 for GCC 9.2 compatibility
          sed -i 's/AX_CXX_COMPILE_STDCXX(\[20\]/AX_CXX_COMPILE_STDCXX([17]/' tools/depends/configure.ac
          # Patch CMake to use C++17
          sed -i 's/CMAKE_CXX_STANDARD 20/CMAKE_CXX_STANDARD 17/' cmake/scripts/common/CompilerSettings.cmake
          
          # AGGRESSIVE FIX: Comment out the C++17 check entirely
          # We know GCC 11 supports C++17, so skip the broken detection
          sed -i 's/^AX_CXX_COMPILE_STDCXX/dnl AX_CXX_COMPILE_STDCXX/' tools/depends/configure.ac
          
          # Verify patches
          echo "=== Patched configure.ac ==="
          grep "AX_CXX_COMPILE_STDCXX" tools/depends/configure.ac || echo "C++17 check disabled"
          echo "=== Patched CompilerSettings.cmake ==="
          grep "CMAKE_CXX_STANDARD" cmake/scripts/common/CompilerSettings.cmake
      
      - name: Install additional native build dependencies
        run: |
          # Install all native tools that Kodi's build system would otherwise compile
          sudo apt-get install -y \
            gettext \
            swig \
            default-jdk \
            liblzo2-dev \
            libgif-dev \
            libjpeg-dev \
            libpng-dev \
            libpcre2-dev \
            libexpat1-dev \
            libwayland-dev \
            wayland-protocols \
            libffi-dev \
            ninja-build \
            meson \
            python3-mako \
            python3-markupsafe \
            python3-pybind11 \
            python3-setuptools \
            texinfo \
            bison \
            flex \
            libtool \
            libtool-bin
          
          # Verify key tools
          echo "CMake: $(cmake --version | head -1)"
          echo "Ninja: $(ninja --version)"
          echo "Meson: $(meson --version)"
          echo "Python: $(python3 --version)"
      
      - name: Ensure native tool wrappers exist
        run: |
          # This step ensures native tools are available regardless of cache state
          # The build expects tools at /home/runner/kodi-tizen-deps/x86_64-linux-gnu-native/bin/
          NATIVE_PREFIX=$HOME/kodi-tizen-deps/x86_64-linux-gnu-native
          mkdir -p $NATIVE_PREFIX/bin
          mkdir -p $NATIVE_PREFIX/lib
          mkdir -p $NATIVE_PREFIX/include
          mkdir -p $NATIVE_PREFIX/share
          
          # Create cmake wrapper (CRITICAL - most builds need this)
          printf '#!/bin/sh\nexec /usr/bin/cmake "$@"\n' > $NATIVE_PREFIX/bin/cmake
          chmod +x $NATIVE_PREFIX/bin/cmake
          
          # Create other essential tool wrappers
          printf '#!/bin/sh\nexec /usr/bin/ninja "$@"\n' > $NATIVE_PREFIX/bin/ninja
          chmod +x $NATIVE_PREFIX/bin/ninja
          
          printf '#!/bin/sh\nexec /usr/bin/make "$@"\n' > $NATIVE_PREFIX/bin/make
          chmod +x $NATIVE_PREFIX/bin/make
          
          printf '#!/bin/sh\nexec /usr/bin/meson "$@"\n' > $NATIVE_PREFIX/bin/meson
          chmod +x $NATIVE_PREFIX/bin/meson
          
          # Create wrappers for autotools and other native tools
          for tool in nasm python3 swig bison m4 autoconf automake autoreconf autoheader aclocal autom4te libtool libtoolize pkg-config gettext msgfmt autopoint msgmerge xgettext; do
            TOOL_PATH=$(command -v $tool 2>/dev/null || true)
            if [ -n "$TOOL_PATH" ]; then
              printf '#!/bin/sh\nexec %s "$@"\n' "$TOOL_PATH" > $NATIVE_PREFIX/bin/$tool
              chmod +x $NATIVE_PREFIX/bin/$tool
            fi
          done
          
          # Create compatibility symlink
          ln -sfn "$NATIVE_PREFIX" "$HOME/kodi-tizen-deps/x86_64-linux-native"
          
          # Verify cmake works
          echo "Verifying cmake at expected path:"
          ls -la $NATIVE_PREFIX/bin/cmake
          $NATIVE_PREFIX/bin/cmake --version
          /home/runner/kodi-tizen-deps/x86_64-linux-gnu-native/bin/cmake --version
          echo "âœ“ Native tools ready"
      
      - name: Build Kodi dependencies
        if: steps.cache-kodi-deps.outputs.cache-hit != 'true'
        run: |
          set -ex  # Enable debug output and exit on error
          
          # Create build-logs directory early
          mkdir -p $GITHUB_WORKSPACE/build-logs
          
          TOOLCHAIN_DIR=$HOME/tizen-studio/tools/arm-linux-gnueabi-gcc-9.2
          export PATH=$TOOLCHAIN_DIR/bin:$PATH
          export TIZEN_SDK=$HOME/tizen-studio
          
          # Use the arm-tizen-linux-gnueabi-* compilers (matches host triplet)
          export CC="$TOOLCHAIN_DIR/bin/arm-tizen-linux-gnueabi-gcc"
          export CXX="$TOOLCHAIN_DIR/bin/arm-tizen-linux-gnueabi-g++"
          export AR="$TOOLCHAIN_DIR/bin/arm-tizen-linux-gnueabi-ar"
          export RANLIB="$TOOLCHAIN_DIR/bin/arm-tizen-linux-gnueabi-ranlib"
          export LD="$TOOLCHAIN_DIR/bin/arm-tizen-linux-gnueabi-ld"
          export AS="$TOOLCHAIN_DIR/bin/arm-tizen-linux-gnueabi-as"
          export NM="$TOOLCHAIN_DIR/bin/arm-tizen-linux-gnueabi-nm"
          export STRIP="$TOOLCHAIN_DIR/bin/arm-tizen-linux-gnueabi-strip"
          export READELF="$TOOLCHAIN_DIR/bin/arm-tizen-linux-gnueabi-readelf"
          export OBJDUMP="$TOOLCHAIN_DIR/bin/arm-tizen-linux-gnueabi-objdump"
          
          export CXXFLAGS="-std=c++17"
          export CFLAGS="-O2"
          
          # Use system CMake instead of building it
          export CMAKE="$(which cmake)"
          export CMAKE_FOR_BUILD="$(which cmake)"
          
          # Use system native tools
          export CC_FOR_BUILD="gcc"
          export CXX_FOR_BUILD="g++"
          export LD_FOR_BUILD="ld"
          
          # Test compiler with C++17
          echo "Testing C++17 support..."
          echo "int main() { return 0; }" | $CXX -std=c++17 -x c++ -c - -o /dev/null && echo "âœ“ C++17 works!" || echo "âœ— C++17 failed"
          
          # Verify we're using the correct compiler
          echo "Compiler being used:"
          echo "CC=$CC"
          $CC --version
          
          echo "CMake being used:"
          $CMAKE --version
          
          cd tools/depends
          ./bootstrap
          
          # Run configure and capture output
          echo "=== Running configure ==="
          ./configure \
            --prefix=$HOME/kodi-tizen-deps \
            --host=arm-tizen-linux-gnueabi \
            --build=x86_64-linux-gnu \
            --with-toolchain="$TOOLCHAIN_DIR" \
            --with-platform=tizen \
            --with-rendersystem=gles \
            --enable-debug=no \
            CC="$CC" \
            CXX="$CXX" \
            AR="$AR" \
            RANLIB="$RANLIB" \
            LD="$LD" \
            AS="$AS" \
            NM="$NM" \
            STRIP="$STRIP" \
            READELF="$READELF" \
            OBJDUMP="$OBJDUMP" \
            CXXFLAGS="$CXXFLAGS" \
            CFLAGS="$CFLAGS" \
            CMAKE="$CMAKE" \
            CMAKE_FOR_BUILD="$CMAKE_FOR_BUILD" 2>&1 || {
              echo "=== Configure failed! ==="
              echo "=== config.log ==="
              cat config.log || true
              exit 1
            }
          
          # Show the generated Makefile.include to verify settings
          echo "=== Generated Makefile.include (first 100 lines) ==="
          head -100 Makefile.include
          
          # Save config.log for debugging
          cp config.log $GITHUB_WORKSPACE/build-logs/configure-config.log || true
          cp Makefile.include $GITHUB_WORKSPACE/build-logs/Makefile.include || true
          
          echo "=== CHECKPOINT 1: Configure completed ==="
          
          # Create the native prefix directory structure
          # CRITICAL: The path MUST match what configure generates in Makefile.include
          # Configure uses: NATIVEPREFIX=/home/runner/kodi-tizen-deps/x86_64-linux-gnu-native
          # This is build_cpu-build_os-native where build_os comes from config.guess
          NATIVE_PREFIX=$HOME/kodi-tizen-deps/x86_64-linux-gnu-native
          mkdir -p $NATIVE_PREFIX/bin
          mkdir -p $NATIVE_PREFIX/lib
          mkdir -p $NATIVE_PREFIX/include
          mkdir -p $NATIVE_PREFIX/share
          mkdir -p $NATIVE_PREFIX/share/automake-1.18
          mkdir -p $NATIVE_PREFIX/share/aclocal
          
          # Copy config.site to the native prefix
          # Create a proper config.site for native builds
          # Note: Using /home/runner directly since $HOME won't expand in quoted heredoc
          cat > $NATIVE_PREFIX/share/config.site << 'CONFIGSITE_EOF'
LD="${LD:-/usr/bin/ld}"
CC="${CC:-/usr/bin/clang}"
CXX="${CXX:-/usr/bin/clang++}"
AR="${AR:-/usr/bin/ar}"
RANLIB="${RANLIB:-/usr/bin/ranlib}"
AS="${AS:-/usr/bin/as}"
NM="${NM:-/usr/bin/nm}"
STRIP="${STRIP:-/usr/bin/strip}"
READELF="${READELF:-/usr/bin/readelf}"
OBJDUMP="${OBJDUMP:-/usr/bin/objdump}"

CFLAGS="-I/home/runner/kodi-tizen-deps/x86_64-linux-gnu-native/include $CFLAGS"
LDFLAGS="-L/home/runner/kodi-tizen-deps/x86_64-linux-gnu-native/lib $LDFLAGS"
CPPFLAGS="-I/home/runner/kodi-tizen-deps/x86_64-linux-gnu-native/include $CPPFLAGS"
CXXFLAGS="-I/home/runner/kodi-tizen-deps/x86_64-linux-gnu-native/include $CXXFLAGS"

PKG_CONFIG=/home/runner/kodi-tizen-deps/x86_64-linux-gnu-native/bin/pkg-config
export PKG_CONFIG_LIBDIR=/home/runner/kodi-tizen-deps/x86_64-linux-gnu-native/lib/pkgconfig

PATH=/home/runner/kodi-tizen-deps/x86_64-linux-gnu-native/bin:$PATH
LD_LIBRARY_PATH=/home/runner/kodi-tizen-deps/x86_64-linux-gnu-native/lib:$LD_LIBRARY_PATH
NASM=/home/runner/kodi-tizen-deps/x86_64-linux-gnu-native/bin/nasm
CONFIGSITE_EOF
          
          echo "Created config.site for native prefix"
          
          echo "=== CHECKPOINT 2: Native prefix created ==="
          
          # Create compatibility symlink for alternate naming convention
          # Some parts of the build may look for x86_64-linux-native instead of x86_64-linux-gnu-native
          ln -sfn "$NATIVE_PREFIX" "$HOME/kodi-tizen-deps/x86_64-linux-native"
          echo "Created compatibility symlink: x86_64-linux-native -> x86_64-linux-gnu-native"
          
          # CRITICAL: Create cmake at the exact path the build expects
          CMAKE_PATH=$(which cmake)
          echo "System cmake at: $CMAKE_PATH"
          echo "Target path: $NATIVE_PREFIX/bin/cmake"
          echo "Absolute target: /home/runner/kodi-tizen-deps/x86_64-linux-gnu-native/bin/cmake"
          
          # Method 1: Try symlink first
          ln -sf "$CMAKE_PATH" "$NATIVE_PREFIX/bin/cmake" 2>/dev/null || true
          
          # Method 2: If symlink doesn't work or isn't executable, copy the binary
          if ! [ -x "$NATIVE_PREFIX/bin/cmake" ]; then
            echo "Symlink failed, copying cmake binary..."
            cp "$CMAKE_PATH" "$NATIVE_PREFIX/bin/cmake"
            chmod +x "$NATIVE_PREFIX/bin/cmake"
          fi
          
          # Method 3: If still not working, create a shell wrapper
          if ! "$NATIVE_PREFIX/bin/cmake" --version >/dev/null 2>&1; then
            echo "Binary copy failed, creating shell wrapper..."
            cat > "$NATIVE_PREFIX/bin/cmake" << 'CMAKEWRAPPER'
#!/bin/sh
exec /usr/bin/cmake "$@"
CMAKEWRAPPER
            chmod +x "$NATIVE_PREFIX/bin/cmake"
          fi
          
          # Final verification - this MUST work or we fail
          echo "=== Final cmake verification ==="
          ls -la "$NATIVE_PREFIX/bin/cmake"
          file "$NATIVE_PREFIX/bin/cmake" || true
          
          echo "Testing cmake execution:"
          "$NATIVE_PREFIX/bin/cmake" --version
          
          echo "Testing absolute path (what Makefile uses):"
          /home/runner/kodi-tizen-deps/x86_64-linux-gnu-native/bin/cmake --version
          
          # If we get here, cmake is working
          echo "âœ“ cmake is working at expected path"
          
          printf '#!/bin/sh\nexec /usr/bin/ninja "$@"\n' > $NATIVE_PREFIX/bin/ninja
          chmod +x $NATIVE_PREFIX/bin/ninja
          
          printf '#!/bin/sh\nexec /usr/bin/make "$@"\n' > $NATIVE_PREFIX/bin/make
          chmod +x $NATIVE_PREFIX/bin/make
          
          printf '#!/bin/sh\nexec /usr/bin/meson "$@"\n' > $NATIVE_PREFIX/bin/meson
          chmod +x $NATIVE_PREFIX/bin/meson
          
          # Create wrapper scripts for other tools
          for tool in nasm python3 swig bison m4 autoconf automake autoreconf autoheader aclocal autom4te libtool libtoolize pkg-config gettext msgfmt autopoint msgmerge xgettext; do
            TOOL_PATH=$(command -v $tool 2>/dev/null || true)
            if [ -n "$TOOL_PATH" ]; then
              printf '#!/bin/sh\nexec %s "$@"\n' "$TOOL_PATH" > $NATIVE_PREFIX/bin/$tool
              chmod +x $NATIVE_PREFIX/bin/$tool
              echo "Created wrapper for $tool -> $TOOL_PATH"
            else
              echo "Warning: $tool not found, skipping"
            fi
          done
          
          # Copy automake data files (version 1.16 on Ubuntu 22.04)
          # But create symlinks for both 1.16 and 1.18 since Makefile.include expects 1.18
          echo "Looking for automake data files..."
          ls -la /usr/share/automake-* 2>/dev/null || echo "No automake directories found"
          
          # Find the automake directory directly
          AUTOMAKE_DIR=$(ls -d /usr/share/automake-* 2>/dev/null | head -1)
          if [ -n "$AUTOMAKE_DIR" ] && [ -d "$AUTOMAKE_DIR" ]; then
            echo "Found automake directory: $AUTOMAKE_DIR"
            # Copy all files, resolving symlinks
            cp -rL "$AUTOMAKE_DIR"/* $NATIVE_PREFIX/share/automake-1.18/ 2>/dev/null || true
            
            # Ensure config.sub and config.guess are actual files (not broken symlinks)
            # These are often symlinks to /usr/share/misc/
            if [ -f /usr/share/misc/config.sub ]; then
              cp /usr/share/misc/config.sub $NATIVE_PREFIX/share/automake-1.18/config.sub
              echo "Copied config.sub from /usr/share/misc/"
            fi
            if [ -f /usr/share/misc/config.guess ]; then
              cp /usr/share/misc/config.guess $NATIVE_PREFIX/share/automake-1.18/config.guess
              echo "Copied config.guess from /usr/share/misc/"
            fi
          else
            echo "Warning: No automake directory found, creating minimal files"
            # Create minimal required files from /usr/share/misc
            cp /usr/share/misc/config.sub $NATIVE_PREFIX/share/automake-1.18/config.sub 2>/dev/null || touch $NATIVE_PREFIX/share/automake-1.18/config.sub
            cp /usr/share/misc/config.guess $NATIVE_PREFIX/share/automake-1.18/config.guess 2>/dev/null || touch $NATIVE_PREFIX/share/automake-1.18/config.guess
          fi
          
          # Copy aclocal files
          cp -r /usr/share/aclocal/* $NATIVE_PREFIX/share/aclocal/ 2>/dev/null || true
          
          # Verify automake files exist
          echo "Automake files:"
          ls -la $NATIVE_PREFIX/share/automake-1.18/ 2>/dev/null | head -10 || echo "No automake files found"
          
          # CRITICAL: Create Toolchain-Native.cmake
          # This is referenced by CMAKE_FOR_BUILD in Makefile.include
          # Note: Using /home/runner directly since $HOME won't expand in quoted heredoc
          cat > $NATIVE_PREFIX/share/Toolchain-Native.cmake << 'TOOLCHAIN_EOF'
set(NATIVEPREFIX "/home/runner/kodi-tizen-deps/x86_64-linux-gnu-native")

set(OS "linux")
set(CMAKE_SYSTEM_PROCESSOR x86_64)
set(CPU "x86_64")
set(ARCH_DEFINES -DTARGET_POSIX -DTARGET_LINUX)

set(CMAKE_SYSTEM_NAME Linux)
set(CMAKE_SYSTEM_VERSION 1)

# specify the native compiler
set(CMAKE_C_COMPILER /usr/bin/clang)
set(CMAKE_CXX_COMPILER /usr/bin/clang++)
set(CMAKE_AR /usr/bin/ar CACHE FILEPATH "Archiver")
set(CMAKE_AS /usr/bin/as CACHE FILEPATH "Assembler")
set(CMAKE_LINKER /usr/bin/ld CACHE FILEPATH "Linker")
set(CMAKE_NM /usr/bin/nm CACHE FILEPATH "Nm")
set(CMAKE_STRIP /usr/bin/strip CACHE PATH "strip binary" FORCE)
set(CMAKE_OBJDUMP /usr/bin/objdump CACHE FILEPATH "Objdump")
set(CMAKE_RANLIB /usr/bin/ranlib CACHE FILEPATH "Ranlib")

set(CMAKE_C_FLAGS "-I${NATIVEPREFIX}/include")
set(CMAKE_CXX_FLAGS "-I${NATIVEPREFIX}/include")
set(CMAKE_EXE_LINKER_FLAGS "-L${NATIVEPREFIX}/lib")

# where is the target environment
set(CMAKE_FIND_ROOT_PATH ${NATIVEPREFIX})
set(CMAKE_LIBRARY_PATH ${NATIVEPREFIX}/lib)

# search for programs in the build host directories
set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
# for libraries and headers in the target directories
set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
set(CMAKE_FIND_FRAMEWORK LAST)

set(ENV{PATH} "${NATIVEPREFIX}/bin:$ENV{PATH}")
TOOLCHAIN_EOF
          
          echo "Created Toolchain-Native.cmake"
          cat $NATIVE_PREFIX/share/Toolchain-Native.cmake
          
          # Verify cmake is accessible and works
          echo "=== CHECKPOINT 3: Wrapper scripts created ==="
          echo "Verifying native tools:"
          ls -la $NATIVE_PREFIX/bin/cmake
          echo "Testing cmake wrapper:"
          $NATIVE_PREFIX/bin/cmake --version
          ls -la $NATIVE_PREFIX/bin/make
          ls -la $NATIVE_PREFIX/bin/autopoint || echo "autopoint not found"
          
          # Also add native prefix to PATH for the build
          export PATH=$NATIVE_PREFIX/bin:$PATH
          
          # CRITICAL: Create the MAIN native/.installed marker file
          # This is what the root Makefile checks to skip native builds
          # The marker uses NATIVEPLATFORM (x86_64-linux-native) NOT NATIVEPREFIX path
          # From Makefile: NATIVE=native/.installed-$(NATIVEPLATFORM)
          # From Makefile.include: NATIVEPLATFORM=x86_64-linux-native
          touch native/.installed-x86_64-linux-native
          
          echo "=== CHECKPOINT 4: Native marker created ==="
          
          # Verify the marker file exists
          echo "Native marker file created:"
          ls -la native/.installed-x86_64-linux-native
          
          # Verify PATH includes native prefix
          echo "PATH: $PATH"
          echo "Testing cmake from PATH:"
          which cmake
          cmake --version
          
          # Now build only target dependencies
          # The native/.installed file tells make that native deps are done
          # Ensure native prefix is in PATH for cmake and other tools
          export PATH=$NATIVE_PREFIX/bin:$PATH
          echo "Building target dependencies with PATH=$PATH"
          
          echo "=== CHECKPOINT 5: Starting make ==="
          
          # CRITICAL: Verify cmake exists at the EXACT path the build expects
          EXPECTED_CMAKE="$HOME/kodi-tizen-deps/x86_64-linux-gnu-native/bin/cmake"
          echo "Checking for cmake at: $EXPECTED_CMAKE"
          ls -la "$EXPECTED_CMAKE" || true
          
          if [ ! -x "$EXPECTED_CMAKE" ]; then
            echo "ERROR: expected cmake not found at $EXPECTED_CMAKE"
            echo "Listing kodi-tizen-deps directory:"
            ls -la $HOME/kodi-tizen-deps/ || true
            echo "Listing native prefix bin dirs:"
            ls -la $HOME/kodi-tizen-deps/*-linux*native/bin/ 2>/dev/null || true
            echo "Listing NATIVE_PREFIX/bin:"
            ls -la $NATIVE_PREFIX/bin/ || true
            exit 1
          fi
          
          echo "Testing cmake execution:"
          "$EXPECTED_CMAKE" --version
          
          # Also verify the path in Makefile.include matches
          echo "CMAKE path from Makefile.include:"
          grep "^CMAKE=" Makefile.include || echo "CMAKE not found in Makefile.include"
          
          # Run make with verbose output and capture errors
          set +e
          make -C target -j$(nproc) V=1 2>&1 | tee /tmp/build.log
          BUILD_EXIT_CODE=${PIPESTATUS[0]}
          set -e
          
          if [ $BUILD_EXIT_CODE -ne 0 ]; then
            echo "=== BUILD FAILED ==="
            echo "Last 200 lines of build log:"
            tail -200 /tmp/build.log
            echo ""
            echo "=== Checking for config.log files ==="
            find . -name "config.log" -exec echo "=== {} ===" \; -exec tail -50 {} \; 2>/dev/null || true
            echo ""
            echo "=== Checking cmake errors ==="
            find . -name "CMakeError.log" -exec echo "=== {} ===" \; -exec cat {} \; 2>/dev/null || true
            
            # Copy logs to workspace for artifact upload
            mkdir -p $GITHUB_WORKSPACE/build-logs
            cp /tmp/build.log $GITHUB_WORKSPACE/build-logs/ || true
            find . -name "config.log" -exec cp {} $GITHUB_WORKSPACE/build-logs/ \; 2>/dev/null || true
            find . -name "CMakeError.log" -exec cp {} $GITHUB_WORKSPACE/build-logs/ \; 2>/dev/null || true
            
            exit $BUILD_EXIT_CODE
          fi
      
      - name: Upload build logs on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: build-logs
          path: build-logs/
          retention-days: 7
          if-no-files-found: ignore
      
      - name: Build Kodi
        run: |
          export PATH=$PATH:$HOME/tizen-studio/tools
          export TIZEN_SDK=$HOME/tizen-studio
          make -C tools/depends/target/cmakebuildsys
          cd build
          make -j$(nproc)
      
      - name: Create TPK package
        run: |
          cd build
          make tpk
          # List created files
          ls -lh *.tpk || echo "No TPK files found"
      
      - name: Get version info
        id: version
        run: |
          VERSION=$(grep "VERSION_MAJOR" version.txt | cut -d' ' -f2).$(grep "VERSION_MINOR" version.txt | cut -d' ' -f2)
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Kodi version: $VERSION"
      
      - name: Upload TPK artifact
        uses: actions/upload-artifact@v4
        with:
          name: kodi-tizen-${{ steps.version.outputs.version }}-arm
          path: build/*.tpk
          retention-days: 30
          if-no-files-found: error
      
      - name: Build summary
        run: |
          echo "## Build Complete! ðŸŽ‰" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### TPK Files Created:" >> $GITHUB_STEP_SUMMARY
          ls -lh build/*.tpk >> $GITHUB_STEP_SUMMARY || echo "No TPK files found" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Installation Instructions:" >> $GITHUB_STEP_SUMMARY
          echo '```bash' >> $GITHUB_STEP_SUMMARY
          echo "# Download the TPK from the Artifacts section above" >> $GITHUB_STEP_SUMMARY
          echo "# Then install on your Samsung TV:" >> $GITHUB_STEP_SUMMARY
          echo "sdb connect <TV_IP>:26101" >> $GITHUB_STEP_SUMMARY
          echo "sdb install kodi-tizen-*.tpk" >> $GITHUB_STEP_SUMMARY
          echo "sdb shell app_launcher -s org.xbmc.kodi" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
